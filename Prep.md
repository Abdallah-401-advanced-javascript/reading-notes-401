# Prep: Engineering Topics
> By Abdallah obaid

**NAME**     | **URL**
------------ | -------------
Home         | [Home](https://abdallah-obaid.github.io/reading-notes-401/).
 Prep        | [Prep: Engineering Topics](https://abdallah-obaid.github.io/reading-notes-401/Prep).
 Read 01     | [Node Ecosystem, TDD, CI/CD](https://abdallah-obaid.github.io/reading-notes-401/class-01).
 Read 02     | [Classes, Inheritance, Functional](https://abdallah-obaid.github.io/reading-notes-401/class-02).
 Read 03     | [Data Modeling & NoSQL Databases](https://abdallah-obaid.github.io/reading-notes-401/class-03).
 Read 04     | [Advanced Mongo/Mongoose](https://abdallah-obaid.github.io/reading-notes-401/class-04).
 Read 05     | [Linked Lists](https://abdallah-obaid.github.io/reading-notes-401/class-05).
 Read 06     | [HTTP and REST](https://abdallah-obaid.github.io/reading-notes-401/class-06).
 Read 07     | [Express](https://abdallah-obaid.github.io/reading-notes-401/class-07).
 Read 08     | [Express Routing & Connected API](https://abdallah-obaid.github.io/reading-notes-401/class-08).
 Read 09     | [API Server](https://abdallah-obaid.github.io/reading-notes-401/class-09).
 Read 10     | [Stacks and Queues](https://abdallah-obaid.github.io/reading-notes-401/class-10).
 Read 11     | [Authentication](https://abdallah-obaid.github.io/reading-notes-401/class-11).
 Read 12     | [OAuth](https://abdallah-obaid.github.io/reading-notes-401/class-12).
 Read 13     | [Bearer Authorization](https://abdallah-obaid.github.io/reading-notes-401/class-13).
 Read 14     | [Access Control (ACL)](https://abdallah-obaid.github.io/reading-notes-401/class-14).
 Read 15     | [Trees](https://abdallah-obaid.github.io/reading-notes-401/class-15).
 Read 16     | [Event Driven Applications](https://abdallah-obaid.github.io/reading-notes-401/class-16).

 
----------------------------------
# A simple set of steps in solving algorithmic problems:-
----------------------------------
   >1. Read the problem completely twice.
     * “measure twice and cut once,”.
     * If you don’t understand the problem, you cannot solve it.
   >2. Solve the problem manually with 3 sets of sample data.
     * Use a Mathematical Induction approach if possible. Using this approach you might try and solve for 1 first, then for 2, then for n.
   >3. Optimize the manual steps.
     * It’s well worth the effort to try and optimize the actual solution or simplify it when it is still in the most easily malleable state.
     * Is there is another way you can solve the problem easier? or if there are some steps you can cut our or simplify.
   >4. Write the manual steps as comments or pseudo-code.
     * This step is for  beginners.
   >5. Replace the comments or pseudo-code with real code.
     * 1-1 line change from pseudo-comments to real code.

   >6. Optimize the real code.
     * Taking a look at your code and figuring out if you can cut out a few lines or do something simpler.
     * All your variables are should be named with long meaningful names.

 ---------------------------------- 
# Act like you make $1000/hr:-
 ----------------------------------
 * “Most people have no clue what they are doing with their time but still complain that they don’t have enough. ” -Grant Cardone, NYT best-selling author.
 * **“The most successful people I know are not busy. They’re focused.”** by Jeff Goins.
 * You teach people how to treat you, if you let people know your time is free and low-valued, people will treat it as such.
 * Treat your time as a valuable commodity, and people will begin to treat it like that, too.
 * **Take stock of the things you did this week. How many of them were worthy of $1,000/hour?**

 ---------------------------------- 
# How to think like a programmer?
 ----------------------------------
* The best way involves:
 >1. Having a framework. 
 >2. Practicing it.
* **“The biggest mistake I see new programmers make is focusing on learning syntax instead of learning how to solve problems.”** — V. Anton Spraul.
* How to know when you understand a problem? When you can explain it in plain English.
* Do not try to solve one big problem. You will cry. Instead, break it into sub-problems. These sub-problems are much easier to solve.
* **“The art of debugging is figuring out what you really told your program to do rather than what you thought you told it to do.”** — Andrew Singer.


 ![Sloving-problems](./Img/Sloving-prob.gif)